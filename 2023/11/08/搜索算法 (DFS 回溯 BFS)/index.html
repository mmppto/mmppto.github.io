<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>搜索算法（DFS/回溯/BFS） | Cynthia的博客</title><meta name="author" content="mmppto"><meta name="copyright" content="mmppto"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="leetcode刷题笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="搜索算法（DFS&#x2F;回溯&#x2F;BFS）">
<meta property="og:url" content="http://mmppto.github.io/2023/11/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%20(DFS%20%E5%9B%9E%E6%BA%AF%20BFS)/index.html">
<meta property="og:site_name" content="Cynthia的博客">
<meta property="og:description" content="leetcode刷题笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/86969838">
<meta property="article:published_time" content="2023-11-08T12:19:00.000Z">
<meta property="article:modified_time" content="2023-11-17T09:32:16.641Z">
<meta property="article:author" content="mmppto">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/86969838"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/favicon.png"><link rel="canonical" href="http://mmppto.github.io/2023/11/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%20(DFS%20%E5%9B%9E%E6%BA%AF%20BFS)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '搜索算法（DFS/回溯/BFS）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-17 17:32:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/86969838" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Link</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/index.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Cynthia的博客"><span class="site-name">Cynthia的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Link</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">搜索算法（DFS/回溯/BFS）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-08T12:19:00.000Z" title="发表于 2023-11-08 20:19:00">2023-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-17T09:32:16.641Z" title="更新于 2023-11-17 17:32:16">2023-11-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="搜索算法（DFS/回溯/BFS）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="搜索算法-DFS-回溯-BFS"><a href="#搜索算法-DFS-回溯-BFS" class="headerlink" title="搜索算法 (DFS&#x2F;回溯&#x2F;BFS)"></a>搜索算法 (DFS&#x2F;回溯&#x2F;BFS)</h1><h2 id="回溯-DFS-算法框架"><a href="#回溯-DFS-算法框架" class="headerlink" title="回溯 (DFS) 算法框架"></a>回溯 (DFS) 算法框架</h2><p><strong>回溯三部曲：</strong></p>
<ul>
<li>函数返回值及参数</li>
<li>函数终止条件</li>
<li>函数遍历过程</li>
</ul>
<p><strong>基本框架：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">参数</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足终止条件:</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtrack(路径，选择列表)  <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure>

<h2 id="排列-组合-子集-问题"><a href="#排列-组合-子集-问题" class="headerlink" title="排列 &#x2F; 组合 &#x2F; 子集 问题"></a>排列 &#x2F; 组合 &#x2F; 子集 问题</h2><p><strong>回溯树：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231108155610299.png" alt="image-20231108155610299" style="zoom: 50%;" />

<h3 id="元素无重复不可复选"><a href="#元素无重复不可复选" class="headerlink" title="元素无重复不可复选"></a>元素无重复不可复选</h3><p>这种情况是最常见的</p>
<h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h4><p><strong>题目可见：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/">子集</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []  <span class="comment"># 存储结果集</span></span><br><span class="line">        path = []  <span class="comment"># 存储路径上的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums, startIndex</span>):</span><br><span class="line">            res.append(path[:])  <span class="comment"># 直接放入路径上的结果</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> startIndex == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrack(nums, i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 观察子集树可以更清晰的理解遍历过程</span></span><br></pre></td></tr></table></figure>

<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>组合和子集几乎完全一样，要求得到有两个数的组合其实就是子集树第二层的情况，代码稍微修改即可</p>
<p><strong>题目可见：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/">组合</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">startIndex, n, k</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            endIndex = n - (k - <span class="built_in">len</span>(path)) + <span class="number">1</span>  <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, endIndex + <span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtrack(i + <span class="number">1</span>, n, k)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(<span class="number">1</span>, n, k)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/description/">组合总和|||</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">n, k, startIndex</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(path) &gt; n:  <span class="comment"># 剪枝</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k <span class="keyword">and</span> <span class="built_in">sum</span>(path) == n:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            endIndex = <span class="number">9</span> - (k - <span class="built_in">len</span>(path)) + <span class="number">1</span>  <span class="comment"># 根据必须要有k个数剪枝</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, endIndex + <span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtrack(n, k, i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(n, k, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><p>未剪枝的树如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231108162204046.png" alt="image-20231108162204046"></p>
<p>观察可知红色部分不符合的原因是一个元素被使用多次，所以引入<code>used[]</code>数组记录每个元素是否被使用过，若已经被使用过则直接跳过</p>
<p><strong>题目可见：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">全排列</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums, used</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    backtrack(nums, used)</span><br><span class="line">                    path.pop()</span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        backtrack(nums, used)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="元素可重复不可复选"><a href="#元素可重复不可复选" class="headerlink" title="元素可重复不可复选"></a>元素可重复不可复选</h3><p>这种情况大多数需要先排序处理，让相同的元素相邻</p>
<h4 id="子集-1"><a href="#子集-1" class="headerlink" title="子集"></a>子集</h4><p>未经过去重的树如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231108163820585.png" alt="image-20231108163820585"></p>
<p>观察发现每次重复的情况，均为前一元素与当前元素相同造成的，所以我们的剪枝操作如下</p>
<p><strong>题目可见：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">子集||</a></p>
<ul>
<li>**未使用<code>used[]</code>**数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums, startIndex</span>):</span><br><span class="line">            res.append(path[:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> startIndex == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 剪枝</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; startIndex <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrack(nums, i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>used[]</code>数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums, startIndex</span>):</span><br><span class="line">            res.append(path[:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> startIndex == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 剪枝</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                backtrack(nums, i + <span class="number">1</span>)</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="组合-1"><a href="#组合-1" class="headerlink" title="组合"></a>组合</h4><p>去重思路同上子集</p>
<p><strong>题目可见：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/description/">组合总和||</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># sum 记录当前的和</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">candidates, startIndex, <span class="built_in">sum</span></span>):</span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="comment"># 这里同样可以用 used[] 数组进行去重操作</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; startIndex <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                <span class="built_in">sum</span> += candidates[i]</span><br><span class="line">                backtrack(candidates, i + <span class="number">1</span>, <span class="built_in">sum</span>)</span><br><span class="line">                <span class="built_in">sum</span> -= candidates[i]</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(candidates, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="排列-1"><a href="#排列-1" class="headerlink" title="排列"></a>排列</h4><p>若采用子集的思想进行去重，即<code>i &gt; startIndex and nums[i] == nums[i - 1]</code></p>
<p>则会出现如下图情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231108171436913.png" alt="image-20231108171436913"></p>
<p>观察可知红色的部分会被剪掉，因为在排列问题中<code>startIndex</code>始终为0，此时终止条件<code>len(path) == len(nums)</code>永远无法达到，所以结果集<code>res</code>里面没有存放任何答案。</p>
<p>所以这里我们考虑使用<code>i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]</code>的方法去重，且恰巧排列中运用到了<code>used[]</code>数组，正确去重的排列树如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231108172811542.png" alt="image-20231108172811542"></p>
<p><strong>题目可见：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/7p8L0Z/description/">全排列||</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums, used</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                backtrack(nums, used)</span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        backtrack(nums, used)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="元素无重复可复选"><a href="#元素无重复可复选" class="headerlink" title="元素无重复可复选"></a>元素无重复可复选</h3><h4 id="组合-2"><a href="#组合-2" class="headerlink" title="组合"></a>组合</h4><p>此类只有组合问题，先直接看题</p>
<p><strong>题目可见：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/description/">组合总和</a></p>
<p>组合树如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231108174148200.png" alt="image-20231108174148200"></p>
<p><strong>我们可以发现唯一的区别就是无限的递归，每次循环开始的下标都是从上次循环的下标开始，而不是 +1 后的下标</strong></p>
<p>需要注意的是，我们必须加一个<code>if sum &gt; target: return</code> ，不然真的会停不下来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">candidates, startIndex, <span class="built_in">sum</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                <span class="built_in">sum</span> += candidates[i]</span><br><span class="line">                backtrack(candidates, i, <span class="built_in">sum</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">                <span class="built_in">sum</span> -= candidates[i]</span><br><span class="line"></span><br><span class="line">        backtrack(candidates, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法：集合划分问题"><a href="#回溯算法：集合划分问题" class="headerlink" title="回溯算法：集合划分问题"></a>回溯算法：集合划分问题</h2><p>这里直接引入题目</p>
<h3 id="划分为k个等和子集"><a href="#划分为k个等和子集" class="headerlink" title="划分为k个等和子集"></a>划分为k个等和子集</h3><p><strong>题目可见：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description/">划分为k个相等的子集</a></p>
<p><a target="_blank" rel="noopener" href="https://lfool.github.io/LFool-Notes/algorithm/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%9A%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98.html">详细题解</a></p>
<p><strong>思路：</strong>问题抽象成将<code>n</code>个带数字的球放入<code>k</code>个桶中，使每个桶中的球的数字总和都相等，以球选桶的视角来看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartitionKSubsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 无法分配的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(nums) % k != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        target = <span class="built_in">sum</span>(nums) // k</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先放大数字的球，便于较快的使桶中数字之和超过 target</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 剪枝 1</span></span><br><span class="line">        bucket = [<span class="number">0</span>] * k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums, k, index, bucket</span>):</span><br><span class="line">            <span class="comment"># 此处不进行判断每个桶中数字之和是否等于 target 的原因是</span></span><br><span class="line">            <span class="comment"># 若每个球都能成功放进桶中，则自然每个桶中数字之和都为 target</span></span><br><span class="line">            <span class="comment"># 可以用反证法验证</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                <span class="comment"># 放第一个球的时候，因为所有桶中都没有球，所以放哪个桶都是等价的</span></span><br><span class="line">                <span class="comment"># 这里默认放第一个桶</span></span><br><span class="line">                <span class="comment"># 此剪枝本质上包含在下一个剪枝当中</span></span><br><span class="line">                <span class="keyword">if</span> index == <span class="number">0</span> <span class="keyword">and</span> i != <span class="number">0</span>:  <span class="comment"># 剪枝 2</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 若当前桶中数字总和与前一个桶相同，则分配的结果是等价的，跳过</span></span><br><span class="line">                <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> bucket[i] == bucket[i - <span class="number">1</span>]:  <span class="comment"># 剪枝 3</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 当前桶中再放就要超过 target</span></span><br><span class="line">                <span class="keyword">if</span> bucket[i] + nums[index] &gt; target:  <span class="comment"># 剪枝 4</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                bucket[i] += nums[index]</span><br><span class="line">                <span class="comment"># 若出现满足条件的解立即终止</span></span><br><span class="line">                <span class="keyword">if</span> backtrack(nums, k, index + <span class="number">1</span>, bucket):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                bucket[i] -= nums[index]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> backtrack(nums, k, <span class="number">0</span>, bucket)</span><br></pre></td></tr></table></figure>

<h3 id="火柴拼正方形"><a href="#火柴拼正方形" class="headerlink" title="火柴拼正方形"></a>火柴拼正方形</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/matchsticks-to-square/description/">题目链接</a></p>
<p>思路与<code>划分为k个等和子集</code>一致，将其<code>k</code>设为4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">makesquare</span>(<span class="params">self, matchsticks: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(matchsticks) % <span class="number">4</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        target = <span class="built_in">sum</span>(matchsticks) // <span class="number">4</span></span><br><span class="line">        bucket = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">        matchsticks.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">matchsticks, index, bucket</span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(matchsticks):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> index == <span class="number">0</span> <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> bucket[i] == bucket[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> bucket[i] + matchsticks[index] &gt; target:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                bucket[i] += matchsticks[index]</span><br><span class="line">                <span class="keyword">if</span> backtrack(matchsticks, index + <span class="number">1</span>, bucket):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                bucket[i] -= matchsticks[index]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> backtrack(matchsticks, <span class="number">0</span>, bucket)</span><br></pre></td></tr></table></figure>

<h3 id="公平分发饼干"><a href="#公平分发饼干" class="headerlink" title="公平分发饼干"></a>公平分发饼干</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fair-distribution-of-cookies/description/">题目链接</a></p>
<p><strong>区别：</strong>本题与常规的<code>集合划分问题</code>有所区别，对于之前的问题，题目给出每个桶可容纳的大小，我们根据是否溢出来决定是否选择此桶，但是此题中没有桶可容纳的大小，只是让我们求所有划分中最大值的最小值</p>
<p><strong>思路：</strong>大体思路与<code>划分为k个相等的子集</code>相同，但此题中剪枝操作比较多，详细解释见以下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distributeCookies</span>(<span class="params">self, cookies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        bucket = [<span class="number">0</span>] * k  <span class="comment"># k 个学生作为 k 个桶</span></span><br><span class="line">        cookies.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 优先让值更大的球先选，可以增加回溯的命中率，易于剪枝4</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># res 为结果，初始化为最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">cookies, index, bucket</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> res  <span class="comment"># 引用嵌套函数外的变量</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(cookies):</span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(bucket))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 剪枝1</span></span><br><span class="line">            cnt = <span class="number">0</span>  <span class="comment"># 记录还没有分到零食的学生数量</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> bucket:</span><br><span class="line">                <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt &gt; <span class="built_in">len</span>(cookies) - index:  <span class="comment"># 未分到零食的学生数量大于还剩的零食数量，必然不合理</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                <span class="comment"># 剪枝2</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> index == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 剪枝3</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> bucket[i] == bucket[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 剪枝4</span></span><br><span class="line">                <span class="comment"># 若当前桶中的值已经大于 res，则必然不是最小值，跳过</span></span><br><span class="line">                <span class="comment"># 先前对球进行从大到小排序的操作，可以让桶中数值更快的超过最小值</span></span><br><span class="line">                <span class="keyword">if</span> bucket[i] + cookies[index] &gt; res:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                bucket[i] += cookies[index]</span><br><span class="line">                backtrack(cookies, index + <span class="number">1</span>, bucket)</span><br><span class="line">                bucket[i] -= cookies[index]</span><br><span class="line"></span><br><span class="line">        backtrack(cookies, <span class="number">0</span>, bucket)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="岛屿问题（DFS）"><a href="#岛屿问题（DFS）" class="headerlink" title="岛屿问题（DFS）"></a>岛屿问题（DFS）</h2><p><strong>定义框架</strong></p>
<p>本质其实就是 <code>DFS</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">    n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 越界检查</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前位置为水</span></span><br><span class="line">    <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 否则将当前陆地改为水，代表此处遍历过</span></span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归处理上下左右</span></span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j)  <span class="comment"># 上</span></span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j)  <span class="comment"># 下</span></span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>)  <span class="comment"># 左</span></span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>)  <span class="comment"># 右</span></span><br></pre></td></tr></table></figure>

<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">题目链接</a></p>
<p><strong>思路：</strong>把与1相连的区域进行<code>FloodFill</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">            n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 越界</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前位置为水</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将当前陆地改为水，代表此处遍历过</span></span><br><span class="line">            grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">            dfs(grid, i - <span class="number">1</span>, j)  <span class="comment"># 上</span></span><br><span class="line">            dfs(grid, i + <span class="number">1</span>, j)  <span class="comment"># 下</span></span><br><span class="line">            dfs(grid, i, j - <span class="number">1</span>)  <span class="comment"># 左</span></span><br><span class="line">            dfs(grid, i, j + <span class="number">1</span>)  <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    dfs(grid, i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="统计封闭岛屿的数目"><a href="#统计封闭岛屿的数目" class="headerlink" title="统计封闭岛屿的数目"></a>统计封闭岛屿的数目</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-closed-islands/description/">题目链接</a></p>
<p><strong>前提：</strong>与岸边接壤的岛屿不算封闭岛屿</p>
<p><strong>思路：</strong>先将与岸边接壤的岛屿排除，再统计内部的封闭岛屿数量</p>
<p><strong>相似题目：</strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-enclaves/description/">飞地的数量</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closedIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># FloodFill</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            grid[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            dfs(grid, i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(grid, i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(grid, i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i, j + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 上下两边的岛屿排除</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> grid[<span class="number">0</span>][i] == <span class="number">0</span>:</span><br><span class="line">                dfs(grid, <span class="number">0</span>, i)</span><br><span class="line">            <span class="keyword">if</span> grid[n - <span class="number">1</span>][i] == <span class="number">0</span>:</span><br><span class="line">                dfs(grid, n - <span class="number">1</span>, i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左右两侧岛屿排除</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> grid[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                dfs(grid, i, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> grid[i][m - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                dfs(grid, i, m - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 统计内部岛屿数量</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    dfs(grid, i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/description/">题目链接</a></p>
<p><strong>方法一：</strong><code>dfs</code>数组返回值设置为当前岛屿面积</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># FloodFill的同时返回岛屿的面积</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">            <span class="comment"># 越界，岛屿大小为0</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前位置为海洋，岛屿大小为0</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 填充，代表已经遍历过此陆地</span></span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回当前位置的一个陆地及其上下左右分支上的陆地数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(grid, i - <span class="number">1</span>, j) + dfs(grid, i + <span class="number">1</span>, j) + dfs(grid, i, j - <span class="number">1</span>) + dfs(grid, i, j + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dfs(grid, i, j))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong>设置一个全局变量<code>s</code>记录每次岛屿的面积</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> s</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            dfs(grid, i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(grid, i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(grid, i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i, j + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    s = <span class="number">0</span></span><br><span class="line">                    dfs(grid, i, j)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, s)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="统计子岛屿"><a href="#统计子岛屿" class="headerlink" title="统计子岛屿"></a>统计子岛屿</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-sub-islands/description/">题目链接</a></p>
<p><strong>方法一：</strong>设置全局变量<code>tag</code>记录<code>grid2</code>中的岛屿是否为<code>grid1</code>的子岛屿</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubIslands</span>(<span class="params">self, grid1: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], grid2: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(grid1), <span class="built_in">len</span>(grid1[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid1, grid2, i, j</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> tag</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 越界检查</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">			</span><br><span class="line">            <span class="comment"># 该位置为水</span></span><br><span class="line">            <span class="keyword">if</span> grid2[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 正常 FloodFill</span></span><br><span class="line">            grid2[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若在 grid2 中为陆地但在 grid1 中为水，则该岛屿不能是子岛屿</span></span><br><span class="line">            <span class="keyword">if</span> grid1[i][j] == <span class="number">0</span>:</span><br><span class="line">                tag = <span class="literal">False</span></span><br><span class="line">			</span><br><span class="line">            <span class="comment"># 遍历当前位置的上下左右</span></span><br><span class="line">            dfs(grid1, grid2, i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(grid1, grid2, i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(grid1, grid2, i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(grid1, grid2, i, j + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> grid2[i][j] == <span class="number">1</span>:</span><br><span class="line">                    tag = <span class="literal">True</span></span><br><span class="line">                    dfs(grid1, grid2, i, j)</span><br><span class="line">                    <span class="keyword">if</span> tag:  <span class="comment"># 若 grid2 中岛屿的所有陆地在 grid1 相同位置也有，则 tag 一直为 True，说明当前岛屿为子岛屿</span></span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong>遍历<code>grid2</code>中所有的陆地，若在<code>grid1</code>中的相同位置为水，则<code>grid2</code>中该陆地所在的岛屿不是子岛屿，将其填充。遍历完成后，此时<code>grid2</code>中岛屿皆为子岛屿</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubIslands</span>(<span class="params">self, grid1: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], grid2: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(grid1), <span class="built_in">len</span>(grid1[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid2, i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> grid2[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            grid2[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            dfs(grid2, i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(grid2, i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(grid2, i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(grid2, i, j + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> grid2[i][j] == <span class="number">1</span> <span class="keyword">and</span> grid1[i][j] != <span class="number">1</span>:</span><br><span class="line">                    dfs(grid2, i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> grid2[i][j] == <span class="number">1</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    dfs(grid2, i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/description/">题目链接</a></p>
<p><strong>方法一（DFS）：</strong>首先遍历边缘上的陆地，将其所在岛屿的所有陆地标记为<code>A</code>，其次遍历整个<code>board</code>，将内部封闭岛屿的的所有陆地<code>O</code>改为水<code>X</code>，最终将与边缘接壤的岛屿中的所有陆地变回<code>O</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">board, i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            board[i][j] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">            dfs(board, i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(board, i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(board, i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(board, i, j + <span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 上下边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                dfs(board, <span class="number">0</span>, i)</span><br><span class="line">            <span class="keyword">if</span> board[n - <span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                dfs(board, n - <span class="number">1</span>, i)</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 左右边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                dfs(board, i, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> board[i][m - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                dfs(board, i, m - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二（并查集）：</strong></p>
<p><a target="_blank" rel="noopener" href="https://lfool.github.io/LFool-Notes/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find.html">并查集详解</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        parent = [<span class="number">0</span>] * (n * m + <span class="number">1</span>)  <span class="comment"># 存储父节点</span></span><br><span class="line">        size = [<span class="number">0</span>] * (n * m + <span class="number">1</span>)  <span class="comment"># 存储连通分量中的节点数（只有根节点的size才能代表整个连通分量中的节点数）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n * m + <span class="number">1</span>):  <span class="comment"># 初始化并查集</span></span><br><span class="line">            parent[i] = i</span><br><span class="line">            size[i] = <span class="number">1</span></span><br><span class="line">        dummy = n * m  <span class="comment"># 虚拟节点，用于连接边界上的陆地</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寻找x节点的祖宗节点 （路径压缩）接近于O(1)的复杂度</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> parent[x] != x:</span><br><span class="line">                parent[x] = find(parent[x])</span><br><span class="line">            <span class="keyword">return</span> parent[x]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将两个不在一个连通分量的节点放在同一个连通分量中</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x, y</span>):</span><br><span class="line">            root_x = find(x)</span><br><span class="line">            root_y = find(y)</span><br><span class="line">            <span class="keyword">if</span> root_x == root_y:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 平衡性优化 尽量保证树的平衡，减少头重脚轻的情况</span></span><br><span class="line">            <span class="comment"># 将节点数量少的分量接到节点数量多的分量上</span></span><br><span class="line">            <span class="keyword">if</span> size[root_x] &gt; size[root_y]:</span><br><span class="line">                size[root_x] += size[root_y]</span><br><span class="line">                parent[root_y] = root_x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                size[root_y] += size[root_x]</span><br><span class="line">                parent[root_x] = root_y</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 检查x，y是否在同一分量中</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">connected</span>(<span class="params">x, y</span>):</span><br><span class="line">            <span class="keyword">return</span> find(x) == find(y)</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 将边界上的陆地与dummy放在一个分量中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                union(dummy, i)</span><br><span class="line">            <span class="keyword">if</span> board[n - <span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                union(dummy, (n - <span class="number">1</span>) * m + i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                union(dummy, i * m)</span><br><span class="line">            <span class="keyword">if</span> board[i][m - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                union(dummy, i * m + m - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 将内部的封闭的点相连，而与边界上的陆地有接壤的陆地，则与dummy放在了同一分量中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                    <span class="keyword">for</span> d <span class="keyword">in</span> directions:</span><br><span class="line">                        next_i = i + d[<span class="number">0</span>]</span><br><span class="line">                        next_j = j + d[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> board[next_i][next_j] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                            union(i * m + j, next_i * m + next_j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;O&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> connected(dummy, i * m + j):</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="太平洋大西洋水流问题"><a href="#太平洋大西洋水流问题" class="headerlink" title="太平洋大西洋水流问题"></a>太平洋大西洋水流问题</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pacific-atlantic-water-flow/description/">题目链接</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>参考<code>被围绕的区域</code>这道题，从四条边入手，我们判断与边相连需要通过高度，只有当前格子比前一个格子高，才能保证水能流入<code>Ocean</code></li>
<li>需要注意的是，之前的题目我们通过修改当前格子的值来表示当前格子已经遍历过的状态，但在此题中我们不能修改格子的值，所以采用<code>visited[][]</code>数组来记录每个格子访问的状态</li>
<li>分两部分，首先求出可以流入<code>Pacific Ocean</code>的格子，再求出可以流入<code>Atlantic Ocean</code>的格子，求两部分相交的格子即可</li>
</ul>
<p><strong>示意图：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231108090852768.png" alt="image-20231108090852768" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pacificAtlantic</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n, m = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        po = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        ao = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 该函数通过 pre 记录前一个格子高度，便于当前格子与前一个格子的高度比较</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">heights, tag, i, j, pre</span>):</span><br><span class="line">            <span class="comment"># 以下三种情况直接说明当前格子无需访问</span></span><br><span class="line">            <span class="comment"># 越界</span></span><br><span class="line">            <span class="comment"># 已经访问过</span></span><br><span class="line">            <span class="comment"># 高度小于前一个格子，此路径无法流入海洋</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m <span class="keyword">or</span> tag[i][j] <span class="keyword">or</span> heights[i][j] &lt; pre:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            tag[i][j] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            dfs(heights, tag, i - <span class="number">1</span>, j, heights[i][j])</span><br><span class="line">            dfs(heights, tag, i + <span class="number">1</span>, j, heights[i][j])</span><br><span class="line">            dfs(heights, tag, i, j - <span class="number">1</span>, heights[i][j])</span><br><span class="line">            dfs(heights, tag, i, j + <span class="number">1</span>, heights[i][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dfs(heights, po, <span class="number">0</span>, i, heights[<span class="number">0</span>][i])</span><br><span class="line">            dfs(heights, ao, n - <span class="number">1</span>, i, heights[n - <span class="number">1</span>][i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此处不能像之前的题目一样省略上一个循环已经遍历过的点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dfs(heights, po, i, <span class="number">0</span>, heights[i][<span class="number">0</span>])</span><br><span class="line">            dfs(heights, ao, i, m - <span class="number">1</span>, heights[i][m - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> po[i][j] <span class="keyword">and</span> ao[i][j]:</span><br><span class="line">                    res.append([i, j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法经典题"><a href="#回溯算法经典题" class="headerlink" title="回溯算法经典题"></a>回溯算法经典题</h2><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/description/">题目链接</a></p>
<p><strong>思路：</strong>解决该问题的关键在于如何剪枝，当右括号的个数多于左括号时，例如<code>)))()</code>，明显是一个错误的结果。正常情况时，每个节点处有两个分支，分支1代表此处选择左括号，分支2代表此处放入右括号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># left 表示已经使用的左括号个数</span></span><br><span class="line">        <span class="comment"># right 表示已经使用的右括号个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">2</span> * n:</span><br><span class="line">                res.append(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 右括号数量大于左括号</span></span><br><span class="line">            <span class="comment"># 如 ()))</span></span><br><span class="line">            <span class="comment"># 必然不合法，剪枝</span></span><br><span class="line">            <span class="keyword">if</span> right &gt; left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 分支1，放入左括号</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                path.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                backtrack(left + <span class="number">1</span>, right)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 分支2，放入右括号</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                path.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                backtrack(left, right + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分||"></a>单词拆分||</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break-ii/description/">题目链接</a></p>
<p><strong>思路：</strong>本题本质上是要对字符串进行分割，保证被分割的每个部分都在<code>wordDict</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">startIndex</span>):</span><br><span class="line">            <span class="keyword">if</span> startIndex == <span class="built_in">len</span>(s):</span><br><span class="line">                res.append(<span class="string">&#x27; &#x27;</span>.join(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">                tmp = s[startIndex:i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> wordDict:  <span class="comment"># 剪枝</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path.append(tmp)</span><br><span class="line">                backtrack(i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="单词拆分-1"><a href="#单词拆分-1" class="headerlink" title="单词拆分"></a>单词拆分</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/description/">题目链接</a></p>
<ul>
<li><strong>动态规划</strong></li>
</ul>
<p>本题参照上题进行回溯会<code>TLE</code>，是因为本题字符串<code>s</code>的长度远大于上一题，导致搜索树更加复杂，故本题不使用回溯算法，这里用动态规划解决</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># dp[i] 表示前 i 个字母组成的单词是否可以由 wordDict 中的单词构成</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 初始化 当一个字母都没有时，可以由其中的单词构成，接着看下面的代码，会发现 dp[0] 必须为 True </span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 遍历前 1-n 个字母组成的单词</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):  <span class="comment"># 对新加入的字母和之前所有的字母可能组成新单词的情况进行遍历</span></span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>回溯（记录状态）</strong></li>
</ul>
<p><strong>分析</strong>：再看回溯算法时，注意到回溯算法仍然是可以优化的，这里首先分析一下导致回溯算法超时的主要原因，先给出一个样例<code>s = &#39;abcd...&#39;, wordDict = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;bc&quot;]</code>，很显然这里的<code>s</code>无法由字典中的单词构成，现在来模拟一下部分回溯的过程如下：</p>
<p>当处于下图的状态时，显然需要回溯，因为后面的部分<code>[d...]</code>无法拆分了</p>
<img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231117165424393.png" alt="image-20231117165424393" style="zoom:50%;" />

<p>在回溯的过程中，会出现以下两种状态，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/image-20231117165629445.png" alt="image-20231117165629445" style="zoom:50%;" />

<p>至此状态时，我们仍然不知道<code>[d...]</code>部分的字符串是否可以拆分成字典中的单词，所以递归的处理<code>[d...]</code>，显然这里存在<strong>重复子问题</strong>，在第一次到达此位置时，我们已经对<code>[d...]</code>部分处理过，已经知道了<code>[d...]</code>是无法拆分的，但是未将此状态给记录下来，导致在第二次到达此位置时，我们重复的处理了这个问题。所以想要避免重复处理，我们只需及时将<code>[d...]</code>不可拆分的状态给记录下来即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># tag[i] 表示从第 i 个字母到最后一个字母组成的单词是否能由字典中的单词构成</span></span><br><span class="line">        <span class="comment"># tag[i] = 0 表示未处理过，= 1 表示可以由字典中的单词构成，= -1 表示不可以</span></span><br><span class="line">        tag = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">startIndex</span>):</span><br><span class="line">            <span class="keyword">if</span> startIndex == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 子问题已经处理过，直接返回结果</span></span><br><span class="line">            <span class="keyword">if</span> tag[startIndex]:</span><br><span class="line">                <span class="keyword">return</span> tag[startIndex] == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">                tmp = s[startIndex:i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> wordDict:  <span class="comment"># 剪枝</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> backtrack(i + <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># [startIndex:len(s)] 内的单词可以由字典中的单词组成</span></span><br><span class="line">                    tag[startIndex] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从 startIndex 位置开始的所有分割方式都不能满足条件</span></span><br><span class="line">            tag[startIndex] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> backtrack(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://mmppto.github.io">mmppto</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mmppto.github.io/2023/11/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%20(DFS%20%E5%9B%9E%E6%BA%AF%20BFS)/">http://mmppto.github.io/2023/11/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%20(DFS%20%E5%9B%9E%E6%BA%AF%20BFS)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mmppto.github.io" target="_blank">Cynthia的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/86969838" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并查集</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/07/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="算法模板"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法模板</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/25/Algorithm/" title="图论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-25</div><div class="title">图论</div></div></a></div><div><a href="/2023/11/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-17</div><div class="title">并查集</div></div></a></div><div><a href="/2023/09/07/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="算法模板"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-07</div><div class="title">算法模板</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/mmppto/PicGo-demo/blog-image/86969838" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mmppto</div><div class="author-info__description">执此一眼，一眼万年。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mmppto"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mmppto" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95-DFS-%E5%9B%9E%E6%BA%AF-BFS"><span class="toc-number">1.</span> <span class="toc-text">搜索算法 (DFS&#x2F;回溯&#x2F;BFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-DFS-%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.</span> <span class="toc-text">回溯 (DFS) 算法框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86-%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">排列 &#x2F; 组合 &#x2F; 子集 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">元素无重复不可复选</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%88%97"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%8F%AF%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">元素可重复不可复选</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%88%97-1"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E5%A4%8D%E5%8F%AF%E5%A4%8D%E9%80%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">元素无重复可复选</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88-2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">组合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%9A%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">回溯算法：集合划分问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">划分为k个等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">火柴拼正方形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">1.3.3.</span> <span class="toc-text">公平分发饼干</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%EF%BC%88DFS%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">岛屿问题（DFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%B0%81%E9%97%AD%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.4.2.</span> <span class="toc-text">统计封闭岛屿的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-number">1.4.3.</span> <span class="toc-text">岛屿的最大面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF"><span class="toc-number">1.4.4.</span> <span class="toc-text">统计子岛屿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.4.5.</span> <span class="toc-text">被围绕的区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.6.</span> <span class="toc-text">太平洋大西洋水流问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">回溯算法经典题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">1.5.1.</span> <span class="toc-text">括号生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">单词拆分||</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">单词拆分</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a><time datetime="2023-11-17T09:31:00.000Z" title="发表于 2023-11-17 17:31:00">2023-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%20(DFS%20%E5%9B%9E%E6%BA%AF%20BFS)/" title="搜索算法（DFS/回溯/BFS）">搜索算法（DFS/回溯/BFS）</a><time datetime="2023-11-08T12:19:00.000Z" title="发表于 2023-11-08 20:19:00">2023-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/07/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="算法模板">算法模板</a><time datetime="2023-09-07T14:37:45.000Z" title="发表于 2023-09-07 22:37:45">2023-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/11/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" title="Linux基础命令">Linux基础命令</a><time datetime="2023-08-11T07:46:00.000Z" title="发表于 2023-08-11 15:46:00">2023-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%9F%BA%E7%A1%80/" title="Java输入输出基础">Java输入输出基础</a><time datetime="2023-08-08T07:18:00.000Z" title="发表于 2023-08-08 15:18:00">2023-08-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By mmppto</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>